-- assignments/03-rsl-lp-db/01-db-setup/01_schema.sql
-- Purpose: Create schema, tables, constraints, indexes, and helpful views.
-- Recommended session setting before running:
--   SET search_path = rsl, public;

-- 0) Ensure schema exists and is owned by rsl_user.
CREATE SCHEMA IF NOT EXISTS rsl AUTHORIZATION rsl_user;

-- Set search path for this session (safe even if schema was just created).
SET search_path = rsl, public;

-- 1) Core entities -----------------------------------------------------------

CREATE TABLE IF NOT EXISTS person (
  id            BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  email         VARCHAR(255) NOT NULL UNIQUE,
  password_hash TEXT         NOT NULL,                          -- store hashes only
  created_at    TIMESTAMPTZ  NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS module (
  id          BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name        VARCHAR(50)  NOT NULL,
  description VARCHAR(255)
);

CREATE TABLE IF NOT EXISTS lesson (
  id          BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  module_id   BIGINT NOT NULL REFERENCES rsl.module(id) ON DELETE CASCADE,
  name        VARCHAR(50)  NOT NULL,
  description VARCHAR(255)
);

CREATE INDEX IF NOT EXISTS idx_lesson_module_id ON lesson(module_id);

CREATE TABLE IF NOT EXISTS step (
  id         BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  lesson_id  BIGINT NOT NULL REFERENCES rsl.lesson(id) ON DELETE CASCADE,
  name       VARCHAR(50)  NOT NULL,
  url        VARCHAR(255),
  notes      TEXT
);

CREATE INDEX IF NOT EXISTS idx_step_lesson_id ON step(lesson_id);

CREATE TABLE IF NOT EXISTS status (
  id   BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name VARCHAR(50) NOT NULL UNIQUE CHECK (name ~ '^[a-z_]+$')
);

-- 2) Progress tables ---------------------------------------------------------

CREATE TABLE IF NOT EXISTS person_module_progress (
  person_id BIGINT NOT NULL REFERENCES rsl.person(id) ON DELETE CASCADE,
  module_id BIGINT NOT NULL REFERENCES rsl.module(id) ON DELETE CASCADE,
  status_id BIGINT NOT NULL REFERENCES rsl.status(id),
  PRIMARY KEY (person_id, module_id)
);

CREATE INDEX IF NOT EXISTS idx_pmp_person_id ON person_module_progress(person_id);
CREATE INDEX IF NOT EXISTS idx_pmp_module_id ON person_module_progress(module_id);
CREATE INDEX IF NOT EXISTS idx_pmp_status_id ON person_module_progress(status_id);

CREATE TABLE IF NOT EXISTS person_lesson_progress (
  person_id BIGINT NOT NULL REFERENCES rsl.person(id) ON DELETE CASCADE,
  lesson_id BIGINT NOT NULL REFERENCES rsl.lesson(id) ON DELETE CASCADE,
  status_id BIGINT NOT NULL REFERENCES rsl.status(id),
  PRIMARY KEY (person_id, lesson_id)
);

CREATE INDEX IF NOT EXISTS idx_plp_person_id ON person_lesson_progress(person_id);
CREATE INDEX IF NOT EXISTS idx_plp_lesson_id ON person_lesson_progress(lesson_id);
CREATE INDEX IF NOT EXISTS idx_plp_status_id ON person_lesson_progress(status_id);

CREATE TABLE IF NOT EXISTS person_step_progress (
  person_id BIGINT NOT NULL REFERENCES rsl.person(id) ON DELETE CASCADE,
  step_id   BIGINT NOT NULL REFERENCES rsl.step(id)   ON DELETE CASCADE,
  status_id BIGINT NOT NULL REFERENCES rsl.status(id),
  PRIMARY KEY (person_id, step_id)
);

CREATE INDEX IF NOT EXISTS idx_psp_person_id ON person_step_progress(person_id);
CREATE INDEX IF NOT EXISTS idx_psp_step_id   ON person_step_progress(step_id);
CREATE INDEX IF NOT EXISTS idx_psp_status_id ON person_step_progress(status_id);

-- 3) Helpful views -----------------------------------------------------------

-- Steps per lesson (for UI counters and progress rollups).
CREATE OR REPLACE VIEW v_lesson_step_counts AS
SELECT
  le.id         AS lesson_id,
  le.module_id,
  COUNT(st.id)  AS step_count
FROM lesson AS le
LEFT JOIN step AS st ON st.lesson_id = le.id
GROUP BY le.id, le.module_id;

-- Percent of completed steps per (person, module).
-- Uses FILTER to count only 'completed' status.
CREATE OR REPLACE VIEW v_person_module_completion AS
WITH steps_in_module AS (
  SELECT st.id AS step_id, le.module_id
  FROM step AS st
  JOIN lesson AS le ON le.id = st.lesson_id
),
totals AS (
  SELECT sim.module_id, COUNT(*) AS total_steps
  FROM steps_in_module AS sim
  GROUP BY sim.module_id
),
completed AS (
  SELECT psp.person_id, sim.module_id,
         COUNT(*) FILTER (WHERE s.name = 'completed') AS completed_steps
  FROM person_step_progress AS psp
  JOIN steps_in_module AS sim ON sim.step_id = psp.step_id
  JOIN status AS s ON s.id = psp.status_id
  GROUP BY psp.person_id, sim.module_id
)
SELECT
  p.id           AS person_id,
  m.id           AS module_id,
  COALESCE(c.completed_steps, 0) AS completed_steps,
  t.total_steps,
  ROUND(
    100.0 * COALESCE(c.completed_steps, 0) / NULLIF(t.total_steps, 0),
    2
  ) AS percent_completed
FROM person AS p
CROSS JOIN module AS m
LEFT JOIN totals   AS t ON t.module_id = m.id
LEFT JOIN completed AS c ON c.person_id = p.id AND c.module_id = m.id;
